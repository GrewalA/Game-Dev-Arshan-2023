<html>
<head>
  <title>Dot Game</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }

    canvas {
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="600" height="600"></canvas>

  <script>
    let disableType = false;
    let GameRunning = false;
    let bulletSpeed = 1000; // Increased bullet reload time
    let bulletTemp = 0;
    let minigunBool = false;
    let minigunTimer = 0;
    let mouseDown = false;
    let canFire = true;
    let enemyCount = 0;
    let died = false;
    let timer = 0;
    let dx = 0;
    let dy = 0;
    let persueDist = 0;
    let distance;
    let factor;
    let mouseX;
    let mouseY;
    let key = [];
    let color = 'white';
    let Speed = 2; // Updated player speed to 2
    let canvas = document.getElementById("gameCanvas");
    let ctx = canvas.getContext("2d");

    // Set the initial position of the player dot
    let playerX = canvas.width / 2;
    let playerY = canvas.height / 2;

    // Set the initial position and properties of the bullets
    let bullets = [];
    const maxBullets = 3;
    const bulletRadius = 3; // Smaller bullet size

    // Set the properties of the dots
    const dotRadius = 8; // Larger dot size
    const playerColor = 'black'; // Changed the player dot color to black
    const enemyColor = 'red';
    const targetColor = 'green';

    // Set the properties of the enemy dots
    const enemyRadius = 8; // Larger enemy dot size
    let enemies = [];

    // Function to handle mouse movement
    function handleMouseMove(event) {
      mouseX = event.clientX - canvas.getBoundingClientRect().left;
      mouseY = event.clientY - canvas.getBoundingClientRect().top;

      dx = mouseX - playerX;
      dy = mouseY - playerY;

      const distance = Math.sqrt(dx * dx + dy * dy);

      // Normalize the direction vector
      dx /= distance;
      dy /= distance;
    }

    // Function to handle key down event
    function handleKeyDown(event) {
      if (event.key === 'w') {
        playerY -= Speed;
      } else if (event.key === 'a') {
        playerX -= Speed;
      } else if (event.key === 's') {
        playerY += Speed;
      } else if (event.key === 'd') {
        playerX += Speed;
      }
    }

    // Function to handle key up event
    function handleKeyUp(event) {
      if (
        (event.key === 'w' || event.key === 'W') &&
        (event.key === 's' || event.key === 'S')
      ) {
        dy = 0;
      } else if (
        (event.key === 'a' || event.key === 'A') &&
        (event.key === 'd' || event.key === 'D')
      ) {
        dx = 0;
      }
    }

    // Function to handle mouse down event
    function handleMouseDown(event) {
      mouseDown = true;
    }

    // Function to handle mouse up event
    function handleMouseUp(event) {
      mouseDown = false;
    }

    // Function to fire a bullet
    function fireBullet() {
      if (bullets.length < maxBullets && canFire) { // Fixed bulletCount variable name
        let bullet = {
          x: playerX,
          y: playerY,
          dx: dx,
          dy: dy,
          radius: bulletRadius,
          color: playerColor
        };

        bullets.push(bullet);

        canFire = false;
        setTimeout(() => {
          canFire = true;
        }, bulletSpeed);
      }
    }

    // Function to create an enemy
    function createEnemy(x, y, dx, dy) {
      let enemy = {
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        radius: enemyRadius,
        color: enemyColor,
        isAlive: true
      };

      enemies.push(enemy);
      enemyCount++;
    }

    // Function to draw the player dot
    function drawPlayer() {
      ctx.beginPath();
      ctx.arc(playerX, playerY, dotRadius, 0, Math.PI * 2);
      ctx.fillStyle = playerColor;
      ctx.fill();
      ctx.closePath();
    }

    // Function to draw the bullets
    function drawBullets() {
      for (let i = 0; i < bullets.length; i++) {
        ctx.beginPath();
        ctx.arc(bullets[i].x, bullets[i].y, bullets[i].radius, 0, Math.PI * 2);
        ctx.fillStyle = bullets[i].color;
        ctx.fill();
        ctx.closePath();
      }
    }

    // Function to draw the enemies
    function drawEnemies() {
      for (let i = 0; i < enemies.length; i++) {
        if (enemies[i].isAlive) {
          ctx.beginPath();
          ctx.arc(enemies[i].x, enemies[i].y, enemies[i].radius, 0, Math.PI * 2);
          ctx.fillStyle = enemies[i].color;
          ctx.fill();
          ctx.closePath();
        }
      }
    }

    // Function to update the position of the bullets
    function updateBullets() {
      for (let i = 0; i < bullets.length; i++) {
        bullets[i].x += bullets[i].dx;
        bullets[i].y += bullets[i].dy;

        if (
          bullets[i].x + bullets[i].radius < 0 ||
          bullets[i].x - bullets[i].radius > canvas.width ||
          bullets[i].y + bullets[i].radius < 0 ||
          bullets[i].y - bullets[i].radius > canvas.height
        ) {
          bullets.splice(i, 1);
        }
      }
    }

    // Function to update the position of the enemies
    function updateEnemies() {
      for (let i = 0; i < enemies.length; i++) {
        if (enemies[i].isAlive) {
          const playerDistX = playerX - enemies[i].x;
          const playerDistY = playerY - enemies[i].y;
          const playerDistance = Math.sqrt(playerDistX * playerDistX + playerDistY * playerDistY);
          enemies[i].dx = playerDistX / playerDistance;
          enemies[i].dy = playerDistY / playerDistance;

          enemies[i].x += enemies[i].dx * Speed;
          enemies[i].y += enemies[i].dy * Speed;

          // Check for collision with player
          if (isCollision(playerX, playerY, dotRadius, enemies[i].x, enemies[i].y, enemies[i].radius)) {
            // Handle player-enemy collision
            // For example, you can end the game or reduce player's health
            gameOver();
          }

          // Check for collision with bullets
          for (let j = 0; j < bullets.length; j++) {
            if (isCollision(bullets[j].x, bullets[j].y, bullets[j].radius, enemies[i].x, enemies[i].y, enemies[i].radius)) {
              // Handle bullet-enemy collision
              // For example, you can remove the enemy and the bullet
              bullets.splice(j, 1);
              enemies[i].isAlive = false;
              break;
            }
          }
        }
      }
    }

    // Function to check for collision between two circles
    function isCollision(x1, y1, r1, x2, y2, r2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < r1 + r2;
    }

    // Function to draw the game
    function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawPlayer();
  drawBullets();
  drawEnemies();
  updateBullets();
  updateEnemies();

  if (mouseDown) {
    fireBullet();
  }
  
  // Spawn new enemy every 2 seconds
  if (timer % 120 === 0) {
    const randomX = Math.random() * canvas.width;
    const randomY = Math.random() * canvas.height;
    const randomDX = Math.random() * 2 - 1;
    const randomDY = Math.random() * 2 - 1;
    createEnemy(randomX, randomY, randomDX, randomDY);
  }
  
  timer++;

  requestAnimationFrame(draw);
}
    // Function to handle key down events
    function handleKeyDown(event) {
      if (event.key === 'w') {
        playerY -= Speed;
      } else if (event.key === 'a') {
        playerX -= Speed;
      } else if (event.key === 's') {
        playerY += Speed;
      } else if (event.key === 'd') {
        playerX += Speed;
      }
    }

    // Function to handle game over
    function gameOver() {
      GameRunning = false;
      alert('Game Over!');
      location.reload(); // Reload the page to restart the game
    }

    // Initialize the game
    function startGame() {
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mousedown', handleMouseDown);
      document.addEventListener('mouseup', handleMouseUp);

      // Create some enemies
      createEnemy(100, 100, 0, 0);
      createEnemy(200, 200, 0, 0);
      createEnemy(300, 300, 0, 0);

      GameRunning = true;
      draw();
    }

    startGame();
  </script>
</body>
</html>
