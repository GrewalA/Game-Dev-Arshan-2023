<html>
<head>
  <title>Dot Game</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }

    canvas {
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="600" height="600"></canvas>

  <script>
    let disableType = false;
    let GameRunning = false;
    let bulletSpeed = 1000; // Increased bullet reload time
    let bulletTemp = 0;
    let minigunBool = false;
    let minigunTimer = 0;
    let mouseDown = false;
    let canFire = true;
    let enemyCount = 0;
    let died = false;
    let timer = 0;
    let dx = 0;
    let dy = 0;
    let persueDist = 0;
    let distance;
    let factor;
    let mouseX;
    let mouseY;
    let key = [];
    let color = 'white';
    let Speed = 3; // Updated player speed to 2
    let canvas = document.getElementById("gameCanvas");
    let ctx = canvas.getContext("2d");

    // Set the initial position of the player dot
    let playerX = canvas.width / 2;
    let playerY = canvas.height / 2;

    // Set the initial position and properties of the bullets
    let bullets = [];
    const maxBullets = 3;
    const bulletRadius = 3; // Smaller bullet size

    // Set the properties of the dots
    const dotRadius = 8; // Larger dot size
    const playerColor = 'black'; // Changed the player dot color to black
    const enemyColor = 'red';
    const targetColor = 'green';

    // Set the properties of the enemy dots
    const enemyRadius = 8; // Larger enemy dot size
    let enemies = [];

    // Function to handle mouse movement
    function handleMouseMove(event) {
      mouseX = event.clientX - canvas.getBoundingClientRect().left;
      mouseY = event.clientY - canvas.getBoundingClientRect().top;

      dx = mouseX - playerX;
      dy = mouseY - playerY;

      const distance = Math.sqrt(dx * dx + dy * dy);

      // Normalize the direction vector
      dx /= distance;
      dy /= distance;
    }

    // Function to handle key down event
    function handleKeyDown(event) {
      if (event.key === 'w') {
        playerY -= Speed;
      } else if (event.key === 'a') {
        playerX -= Speed;
      } else if (event.key === 's') {
        playerY += Speed;
      } else if (event.key === 'd') {
        playerX += Speed;
      }
    }

    // Function to handle key up event
    function handleKeyUp(event) {
      if (
        (event.key === 'w' || event.key === 'W') &&
        (event.key === 's' || event.key === 'S')
      ) {
        dy = 0;
      } else if (
        (event.key === 'a' || event.key === 'A') &&
        (event.key === 'd' || event.key === 'D')
      ) {
        dx = 0;
      }
    }

    // Function to handle mouse down event
    function handleMouseDown(event) {
      mouseDown = true;
    }

    // Function to handle mouse up event
    function handleMouseUp(event) {
      mouseDown = false;
    }

    // Function to handle mouse click event
    function handleMouseClick(event) {
      if (canFire) {
        bullets.push({ x: playerX, y: playerY, dx: dx, dy: dy });
        canFire = false;
        bulletTemp = bulletSpeed;
      }
    }

    // Function to handle enemy dot creation
    function createEnemy() {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      enemies.push({ x: x, y: y, dx: dx, dy: dy });
      enemyCount++;
    }

    // Function to update the positions of the dots
    function update() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw the player dot
      ctx.beginPath();
      ctx.arc(playerX, playerY, dotRadius, 0, Math.PI * 2);
      ctx.fillStyle = playerColor;
      ctx.fill();
      ctx.closePath();

      // Draw the bullets
      for (let i = 0; i < bullets.length; i++) {
        ctx.beginPath();
        ctx.arc(bullets[i].x, bullets[i].y, bulletRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'blue';
        ctx.fill();
        ctx.closePath();
      }

      // Move the bullets
      for (let i = 0; i < bullets.length; i++) {
        bullets[i].x += bullets[i].dx * Speed * 2;
        bullets[i].y += bullets[i].dy * Speed * 2;
      }

      // Remove bullets that are outside the canvas
      bullets = bullets.filter(bullet => {
        return (
          bullet.x >= 0 &&
          bullet.x <= canvas.width &&
          bullet.y >= 0 &&
          bullet.y <= canvas.height
        );
      });

      // Draw the enemy dots
      for (let i = 0; i < enemies.length; i++) {
        ctx.beginPath();
        ctx.arc(enemies[i].x, enemies[i].y, enemyRadius, 0, Math.PI * 2);
        ctx.fillStyle = enemyColor;
        ctx.fill();
        ctx.closePath();
      }

      // Move the enemy dots
      for (let i = 0; i < enemies.length; i++) {
        enemies[i].x += enemies[i].dx * Speed;
        enemies[i].y += enemies[i].dy * Speed;
      }

      // Remove enemies that are outside the canvas
      enemies = enemies.filter(enemy => {
        return (
          enemy.x >= 0 &&
          enemy.x <= canvas.width &&
          enemy.y >= 0 &&
          enemy.y <= canvas.height
        );
      });

      // Check for collisions between bullets and enemies
      for (let i = 0; i < bullets.length; i++) {
        for (let j = 0; j < enemies.length; j++) {
          distance = Math.sqrt(
            Math.pow(enemies[j].x - bullets[i].x, 2) +
              Math.pow(enemies[j].y - bullets[i].y, 2)
          );

          if (distance < enemyRadius + bulletRadius) {
            enemies.splice(j, 1);
            bullets.splice(i, 1);
            enemyCount--;
            break;
          }
        }
      }

      // Check for collisions between player and enemies
      for (let i = 0; i < enemies.length; i++) {
        distance = Math.sqrt(
          Math.pow(enemies[i].x - playerX, 2) +
            Math.pow(enemies[i].y - playerY, 2)
        );

        if (distance < enemyRadius + dotRadius) {
          GameRunning = false;
          disableType = false;
          died = true;
          alert('Game Over!');
          break;
        }
      }

      // Update bullet reload time
      if (!canFire) {
        bulletTemp--;
        if (bulletTemp <= 0) {
          canFire = true;
        }
      }

      // Update minigun powerup timer
      if (minigunBool) {
        minigunTimer--;
        if (minigunTimer <= 0) {
          minigunBool = false;
          bulletSpeed = 1000; // Reset bullet reload time
        }
      }

      // Check if the game is still running
      if (GameRunning) {
        requestAnimationFrame(update);
      }
    }

    // Function to start the game
    function startGame() {
      disableType = true;
      GameRunning = true;
      enemyCount = 0;
      enemies = [];
      bullets = [];
      playerX = canvas.width / 2;
      playerY = canvas.height / 2;
      timer = 0;
      minigunBool = false;
      minigunTimer = 0;
      mouseDown = false;
      canFire = true;

      // Add event listeners
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      document.addEventListener('mousedown', handleMouseDown);
      document.addEventListener('mouseup', handleMouseUp);
      document.addEventListener('click', handleMouseClick);

      // Initial enemy spawn
      setTimeout(createEnemy, 0); // Spawn enemy immediately

      // Regular enemy spawn after 3 seconds
      setTimeout(function spawnEnemy() {
        createEnemy();
        setTimeout(spawnEnemy, 3000); // Change delay to 3000 milliseconds (3 seconds)
      }, 3000);
      
      update();
    }

    // Start the game
    startGame();
  </script>
</body>
</html>
