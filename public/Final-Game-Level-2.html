<html>
<head>
  <title>Dot Game</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }

    canvas {
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="400" height="400"></canvas>

  <script>
    let disableType = false;
    let GameRunning = false;
    let bulletSpeed = 300; // Increased bullet speed to 300ms
    let bulletTemp = 0;
    let minigunBool = false;
    let minigunTimer = 0;
    let mouseDown = false;
    let canFire = true;
    let enemyCount = 0;
    let died = false;
    let timer = 0;
    let dx = 0;
    let dy = 0;
    let persueDist = 0;
    let distance;
    let factor;
    let mouseX;
    let mouseY;
    let key = [];
    let color = 'white';
    let Speed = 2; // Increased player movement speed to 2 pixels per frame
    let canvas = document.getElementById("gameCanvas");
    let ctx = canvas.getContext("2d");

    // Set the initial position of the player dot
    let playerX = canvas.width / 2;
    let playerY = canvas.height / 2;

    // Set the initial position and properties of the bullets
    let bullets = [];
    const maxBullets = 3;
    const bulletRadius = 3; // Reduced bullet size to 3 pixels
    let bulletCount = 0;

    // Set the properties of the dots
    const dotRadius = 5; // Reduced dot size to 5 pixels
    const playerColor = 'black'; // Changed the player dot color to black
    const enemyColor = 'red';
    const targetColor = 'green';

    // Set the properties of the enemy dots
    const enemyRadius = 7; // Reduced enemy dot size to 7 pixels
    let enemies = [];

    // Function to handle mouse movement
    function handleMouseMove(event) {
      mouseX = event.clientX - canvas.getBoundingClientRect().left;
      mouseY = event.clientY - canvas.getBoundingClientRect().top;
      
      dx = mouseX - playerX;
      dy = mouseY - playerY;
      
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Normalize the direction vector
      dx /= distance;
      dy /= distance;
    }

    // Function to handle mouse down event
    function handleMouseDown(event) {
      mouseDown = true;
    }

    // Function to handle mouse up event
    function handleMouseUp(event) {
      mouseDown = false;
    }

    // Function to fire a bullet
    function fireBullet() {
      if (bulletCount < maxBullets && canFire) {
        let bullet = {
          x: playerX,
          y: playerY,
          dx: dx * 5, // Increased bullet speed by multiplying dx and dy by 5
          dy: dy * 5,
          radius: bulletRadius,
          color: playerColor
        };

        bullets.push(bullet);
        bulletCount++;

        canFire = false;
        setTimeout(() => {
          canFire = true;
        }, bulletSpeed);
      }
    }

    // Function to create an enemy
    function createEnemy(x, y, dx, dy) {
      let enemy = {
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        radius: enemyRadius,
        color: enemyColor,
        isAlive: true
      };

      enemies.push(enemy);
      enemyCount++;
    }

    // Function to draw the player dot
    function drawPlayer() {
      ctx.beginPath();
      ctx.arc(playerX, playerY, dotRadius, 0, Math.PI * 2);
      ctx.fillStyle = playerColor;
      ctx.fill();
      ctx.closePath();
    }

    // Function to draw the bullets
    function drawBullets() {
      for (let i = 0; i < bullets.length; i++) {
        ctx.beginPath();
        ctx.arc(bullets[i].x, bullets[i].y, bullets[i].radius, 0, Math.PI * 2);
        ctx.fillStyle = bullets[i].color;
        ctx.fill();
        ctx.closePath();
      }
    }

    // Function to draw the enemies
    function drawEnemies() {
      for (let i = 0; i < enemies.length; i++) {
        if (enemies[i].isAlive) {
          ctx.beginPath();
          ctx.arc(enemies[i].x, enemies[i].y, enemies[i].radius, 0, Math.PI * 2);
          ctx.fillStyle = enemies[i].color;
          ctx.fill();
          ctx.closePath();
        }
      }
    }

    // Function to update the position of the bullets
    function updateBullets() {
      for (let i = 0; i < bullets.length; i++) {
        bullets[i].x += bullets[i].dx;
        bullets[i].y += bullets[i].dy;

        if (
          bullets[i].x + bullets[i].radius < 0 ||
          bullets[i].x - bullets[i].radius > canvas.width ||
          bullets[i].y + bullets[i].radius < 0 ||
          bullets[i].y - bullets[i].radius > canvas.height
        ) {
          bullets.splice(i, 1);
          bulletCount--;
        }
      }
    }

    // Function to update the position of the enemies
    function updateEnemies() {
      for (let i = 0; i < enemies.length; i++) {
        if (enemies[i].isAlive) {
          enemies[i].x += enemies[i].dx;
          enemies[i].y += enemies[i].dy;

          // Check for collision with player
          if (isCollision(playerX, playerY, dotRadius, enemies[i].x, enemies[i].y, enemies[i].radius)) {
            // Handle player-enemy collision
            // For example, you can end the game or reduce player's health
            console.log('Player collided with an enemy!');
            died = true;
          }

          // Check for collision with bullets
          for (let j = 0; j < bullets.length; j++) {
            if (isCollision(bullets[j].x, bullets[j].y, bullets[j].radius, enemies[i].x, enemies[i].y, enemies[i].radius)) {
              // Handle bullet-enemy collision
              // For example, you can remove the enemy and the bullet
              bullets.splice(j, 1);
              bulletCount--;
              enemies[i].isAlive = false;
              enemyCount--;
              break;
            }
          }
        }
      }
    }

    // Function to check for collision between two circles
    function isCollision(x1, y1, r1, x2, y2, r2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < r1 + r2;
    }

    // Function to draw the game
   function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawPlayer();
  drawBullets();
  drawEnemies();
  updateBullets();
  updateEnemies();

  if (mouseDown && !died) {
    fireBullet();
  }
  
  // Spawn new enemy every 2 seconds
  if (timer % 120 === 0 && !died) {
    const randomX = Math.random() * canvas.width;
    const randomY = Math.random() * canvas.height;
    const randomDX = Math.random() * 2 - 1;
    const randomDY = Math.random() * 2 - 1;
    createEnemy(randomX, randomY, randomDX, randomDY);
  }
  
  timer++;

  requestAnimationFrame(draw);
}

    // Initialize the game
    function startGame() {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mousedown', handleMouseDown);
      document.addEventListener('mouseup', handleMouseUp);

      // Create some enemies
      createEnemy(100, 100, 1, 1);
      createEnemy(200, 200, -1, 1);
      createEnemy(300, 300, 1, -1);

      draw();
    }

    startGame();
  </script>
</body>
</html>
